diff --git a/include/simgrid/plugins/temperature.h b/include/simgrid/plugins/temperature.h
new file mode 100644
index 000000000..75c1ee7be
--- /dev/null
+++ b/include/simgrid/plugins/temperature.h
@@ -0,0 +1,30 @@
+/* Copyright (c) 2016-2017. The SimGrid Team. All rights reserved.          */
+
+/* This program is free software; you can redistribute it and/or modify it
+ * under the terms of the license (GNU LGPL) which comes with this package. */
+
+#ifndef SIMGRID_PLUGINS_TEMPERATURE_H_
+#define SIMGRID_PLUGINS_TEMPERATURE_H_
+
+#include <xbt/base.h>
+#include <simgrid/forward.h>
+
+SG_BEGIN_DECL()
+
+XBT_PUBLIC void sg_host_temperature_plugin_init();
+XBT_PUBLIC double sg_host_get_processor_temperature(sg_host_t host);
+XBT_PUBLIC double sg_host_get_air_temperature(sg_host_t host);
+XBT_PUBLIC void sg_host_set_outside_temperature(sg_host_t host, double temperature);
+XBT_PUBLIC void sg_host_update_temperatures(sg_host_t host);
+
+
+
+#define MSG_host_temperature_plugin_init() sg_host_temperature_plugin_init()
+#define MSG_host_get_processor_temperature(host) sg_host_get_processor_temperature(host)
+#define MSG_host_get_air_temperature(host) sg_host_get_air_temperature(host)
+#define MSG_host_set_outside_temperature(host, temperature) sg_host_set_outside_temperature(host, temperature)
+#define MSG_host_update_temperatures(host) sg_host_update_temperatures(host)
+
+SG_END_DECL()
+
+#endif
\ No newline at end of file
diff --git a/src/plugins/host_temperature.cpp b/src/plugins/host_temperature.cpp
new file mode 100644
index 000000000..1d3515881
--- /dev/null
+++ b/src/plugins/host_temperature.cpp
@@ -0,0 +1,495 @@
+/* Copyright (c) 2010-2018. The SimGrid Team. All rights reserved.          */
+
+/* This program is free software; you can redistribute it and/or modify it
+ * under the terms of the license (GNU LGPL) which comes with this package. */
+
+#include "simgrid/plugins/temperature.h"
+#include "simgrid/plugins/energy.h"
+#include "simgrid/s4u/Engine.hpp"
+#include "src/include/surf/surf.hpp"
+#include "src/plugins/vm/VirtualMachineImpl.hpp"
+#include "src/surf/cpu_interface.hpp"
+
+#include <boost/algorithm/string/classification.hpp>
+#include <boost/algorithm/string/split.hpp>
+
+#include <string>
+#include <cmath>
+
+SIMGRID_REGISTER_PLUGIN(host_temperature, "CPU and ambient temperature.", &sg_host_temperature_plugin_init)
+
+/** @addtogroup plugin_temperature
+
+This is the temperature plugin, enabling to account not only for computation time, but also for the temperature in the
+simulated platform.
+To activate this plugin, first call sg_host_temperature_plugin_init() before your #MSG_init(), and then use
+MSG_host_get_proc_temperature() to retrieve the temperature of a given host.
+It is also possible to retrieve the ambient air temperature with MSG_host_get_air_temperature().
+
+When the host is on, this temperature naturally depends on the energy consumed by the processor, calculated by the energy plugin.
+This model is based on the thermodynamics heat formula. Please consult <a href="http://www.softschools.com/formulas/physics/specific_heat_formula/61/">this page</a> to see more details.
+TODO: This model is OK for a first iteration of the temperature plugin. More work to improve the model is necessary.
+
+Here is an example of XML declaration:
+
+\code{.xml}
+<host id="MyHost1" speed="100.0Mf,50.0Mf,20.0Mf" pstate="0" core="4" >
+      <prop id="watt_per_state" value="100.0:120.0:200.0, 93.0:110.0:170.0, 90.0:105.0:150.0" />
+        <prop id="watt_off" value="10" />
+        <prop id="proc_magic_number" value="3"/>
+        <prop id="proc_specific_heat" value="0.39"/>
+        <prop id="grams_proc_mass" value="150"/>
+        <prop id="air_temperature" value="20.0"/>
+        <prop id="air_magic_number" value="2.0"/>
+        <prop id="air_specific_heat" value="1.005"/>
+        <prop id="grams_air_mass" value="36000"/>
+    </host>
+\endcode
+
+### How accurate are these models?
+
+This model is at its first iteration. Further evaluation of its accuracy is needed. Please keep this in mind when using this plugin.
+ */
+
+XBT_LOG_NEW_DEFAULT_SUBCATEGORY(surf_temperature, surf, "Logging specific to the SURF temperature plugin");
+
+namespace simgrid {
+namespace plugin {
+
+class HostTemperature {
+public:
+  static simgrid::xbt::Extension<simgrid::s4u::Host, HostTemperature> EXTENSION_ID;
+
+  explicit HostTemperature(simgrid::s4u::Host *ptr);
+  ~HostTemperature();
+
+  double getProcessorTemperature();
+  double getAirTemperature();
+  double getEnergyConsumed();
+  void setOutsideTemperature(double temperature);
+  double getOutsideTemperature();
+  void update();
+
+private:
+  simgrid::s4u::Host *host = nullptr;
+public:
+  double air_temperature = 20.0;/*< Temperature of the cooling air (in Celsius) where the host is located >*/
+  double proc_temperature = air_temperature; /*< Current temperature (in Celsius) of the host >*/
+  double outside_temperature = 15.0;/*< Temperature of the outside world (in Celsius). Used to model the heat transfer b/w the air and the outside world >*/
+  
+  double proc_magic_number = 1.6; /*< Thermal conductivity of proc * area / thickness (in Watt/Kelvin)>*/
+  double processor_specific_heat = 0.39; /*< Specific heat of the processor, defaulted to the value of copper in joules/(grams*kelvin)>*/
+  double processor_mass = 150; /*< Processor mass in grams >*/
+
+  double air_specific_heat = 1.005; /*< Specific heat of the air, defaulted to the value of air in joules/(grams*kelvin)>*/
+  double air_magic_number = 10.4; /*< Cooling power between the air and outside world (roughly air_magic_number = 2 * area of windows in the room) >*/
+  double air_mass = 36000; /*< Air mass in grams, arbitrary values for a room of 30m^3 of air at 20°C >*/
+
+  double last_energy;        /*< Amount of energy used so far >*/
+  double last_updated;       /*< Timestamp of the last temperature update event >*/
+};
+
+simgrid::xbt::Extension<simgrid::s4u::Host, HostTemperature> HostTemperature::EXTENSION_ID;
+
+/* Computes the temperature. Called lazily on need. */
+void HostTemperature::update()
+{
+  if (dynamic_cast<simgrid::s4u::VirtualMachine*>(host)) // Ignore virtual machines
+      return;
+  if (!strcmp(host->get_cname(),"master_host") || (!strcmp(host->get_cname(), "storage_server"))) // Ignore master_host and storage_server of Batsim
+      return;
+  
+  double start_time  = this->last_updated;
+  double finish_time = surf_get_clock();
+  double elapsed_time = finish_time - start_time;
+
+  if(elapsed_time < 1){
+    /*< we do not update if the time period is too small >*/
+    return;
+  }
+
+  double new_energy = sg_host_get_consumed_energy(host);
+  double consumed_energy_at_period = new_energy - this->last_energy; /*< Energy consumed in this time period >*/
+
+  /*< Compute the number of timesteps of about 10 seconds >*/
+  int nb_timesteps;
+  double timestep;
+  double energy_per_step;
+  if(elapsed_time > 10.0){
+    nb_timesteps = (int) round(elapsed_time / 10.0);
+    timestep = elapsed_time / (double)nb_timesteps;
+    energy_per_step = consumed_energy_at_period / (double)nb_timesteps;
+  }
+  else{
+    nb_timesteps = 1;
+    timestep = elapsed_time;
+    energy_per_step = consumed_energy_at_period;
+  }
+
+  /* For debugging purpose */
+  //XBT_INFO("---------------[%.2f] Host %s: %.2f J in %.2f s; %d steps of %.4f s", finish_time, host->get_cname(), consumed_energy_at_period, elapsed_time, nb_timesteps, timestep);
+  //double tot_proc_energy_lost = 0, tot_proc_energy_kept = 0, tot_air_energy_lost = 0, tot_air_energy_kept = 0;
+  /* End Debug*/
+
+  double tmp_proc_temperature = this->proc_temperature;
+  double tmp_air_temperature = this->air_temperature;
+  double proc_energy_lost, proc_energy_kept, proc_temperature_change, new_proc_temperature = this->proc_temperature;
+  double air_energy_lost, air_energy_kept, air_temperature_change, new_air_temperature = this->air_temperature;
+
+  /*< We update the temperatures of the host and the ambient air by timesteps of about 10 seconds (which is roughly *continuous*) >*/
+  for(int i = 0; i< nb_timesteps; ++i){
+    /*< Computes the temperature change of the processor >*/
+    proc_energy_lost = timestep * this->proc_magic_number * (tmp_proc_temperature - tmp_air_temperature);
+    proc_energy_kept = energy_per_step - proc_energy_lost;
+    proc_temperature_change = proc_energy_kept / (this->processor_mass * this->processor_specific_heat);
+    new_proc_temperature = tmp_proc_temperature + proc_temperature_change;
+
+    /*<Computes the temperature change of the air >*/
+    air_energy_lost = timestep * this->air_magic_number * (tmp_air_temperature - this->outside_temperature);
+    air_energy_kept = proc_energy_lost - air_energy_lost;
+    air_temperature_change = air_energy_kept / (this->air_mass * this->air_specific_heat);
+    new_air_temperature = tmp_air_temperature + air_temperature_change;
+
+    tmp_proc_temperature = new_proc_temperature;
+    tmp_air_temperature = new_air_temperature;
+
+    /* For debugging purpose */
+    /*tot_proc_energy_kept += proc_energy_kept;
+    tot_proc_energy_lost += proc_energy_lost;
+    tot_air_energy_kept += air_energy_kept;
+    tot_air_energy_lost += air_energy_lost;*/
+    /* End Debug */
+  }
+
+  /* For debugging purpose */
+  /*XBT_INFO("---------------[%.2f] Host %s: elapsed_time %.2fs; energy %.2fJ; proc_lost %.2fJ proc_kept %.2fJ old_temp %.6f°C new_temp %.6f°C", finish_time, host->get_cname(), elapsed_time, consumed_energy_at_period,
+          tot_proc_energy_lost, tot_proc_energy_kept, this->proc_temperature, new_proc_temperature);
+  XBT_INFO("---------------[%.2f] Host %s: elapsed_time %.2fs; energy %.2fJ; air_lost %.2fJ air_kept %.2fJ old_air %.6f°C new_air %.6f°C outside_temp %.2f°C", finish_time, host->get_cname(), elapsed_time, consumed_energy_at_period,
+          tot_air_energy_lost, tot_air_energy_kept, this->air_temperature, new_air_temperature, this->outside_temperature);*/
+  /* End Debug */
+
+  XBT_DEBUG("[update_temperature of %s] period=[%.2f-%.2f]; current power peak=%.0E flop/s; processor temperature: %.2f °C -> "
+            "%.2f °C; air temperature: %.2f °C -> %.2f °C; Outside temperature: %.2f °C.",
+            host->get_cname(), start_time, finish_time, host->pimpl_cpu->get_speed(1.0), this->proc_temperature,
+            new_proc_temperature, this->air_temperature, new_air_temperature, this->outside_temperature);
+
+  this->proc_temperature = new_proc_temperature;
+  this->air_temperature = new_air_temperature;
+  this->last_updated = finish_time;
+  this->last_energy = new_energy;
+}
+
+HostTemperature::HostTemperature(simgrid::s4u::Host* ptr) : host(ptr), last_updated(surf_get_clock())
+{
+  if (!strcmp(host->get_cname(),"master_host") || (!strcmp(host->get_cname(), "storage_server"))) // Ignore master_host and storage_server of Batsim
+      return;
+
+  this->last_energy = sg_host_get_consumed_energy(host);
+
+  /*
+   * Read some properties from the platform xml file
+   */
+
+  // air_temperature
+  const char* air_temp_str = host->get_property("air_temperature");
+  if (air_temp_str != nullptr) {
+    try {
+      this->air_temperature = std::stof(std::string(air_temp_str));
+    } catch (std::invalid_argument& ia) {
+      throw std::invalid_argument(std::string("Invalid value for property air_temperature of host ") + host->get_cname() +
+                                  ": " + air_temp_str);
+    }
+  } else{
+    XBT_WARN("Missing value for property air_temperature of host %s: Using default value %.2f Celcius (NTP standard)", host->get_cname(),
+            this->air_temperature);
+  }
+
+  // processor temperature
+  const char* proc_temp_str = host->get_property("proc_temperature");
+  if (proc_temp_str != nullptr) {
+    try {
+      this->proc_temperature = std::stof(std::string(proc_temp_str));
+    } catch (std::invalid_argument& ia) {
+      throw std::invalid_argument(std::string("Invalid value for property proc_temperature of host ") + host->get_cname() +
+                                  ": " + proc_temp_str);
+    }
+  } else{
+    /*XBT_WARN("Missing value for property proc_temperature of host %s: Using default value %.2f Celcius (NTP standard)", host->get_cname(),
+            this->proc_temperature);*/
+    this->proc_temperature = this->air_temperature;
+  }
+
+  // processor magic number related to conductive heat transfer
+  const char* sp_number_str = host->get_property("proc_magic_number");
+  if (sp_number_str != nullptr) {
+    try {
+      this->proc_magic_number = std::stof(std::string(sp_number_str));
+    } catch (std::invalid_argument& ia) {
+      throw std::invalid_argument(std::string("Invalid value for property proc_magic_number of host ") + host->get_cname() +
+                                  ": " + sp_number_str);
+    }
+  } else{
+    XBT_WARN("Missing value for property proc_magic_number of host %s: Using default value %.2f", host->get_cname(),
+            this->proc_magic_number);
+  }
+
+  // processor_specific_heat
+  const char* sp_heat_str = host->get_property("proc_specific_heat");
+  if (sp_heat_str != nullptr) {
+    try {
+      this->processor_specific_heat = std::stof(std::string(sp_heat_str));
+    } catch (std::invalid_argument& ia) {
+      throw std::invalid_argument(std::string("Invalid value for property proc_specific_heat of host ") + host->get_cname() +
+                                  ": " + sp_heat_str);
+    }
+  } else{
+    XBT_WARN("Missing value for property proc_specific_heat of host %s: Using default value %.2f", host->get_cname(),
+            this->processor_specific_heat);
+  }
+
+  // processor_mass
+  const char* proc_mass_str = host->get_property("grams_proc_mass");
+  if (proc_mass_str != nullptr) {
+    try {
+      this->processor_mass = std::stof(std::string(proc_mass_str));
+    } catch (std::invalid_argument& ia) {
+      throw std::invalid_argument(std::string("Invalid value for property grams_processor_mass of host ") + host->get_cname() +
+                                  ": " + proc_mass_str);
+    }
+  } else{
+  XBT_WARN("Missing value for property grams_processor_mass of host %s: Using default value %.2f grams", host->get_cname(),
+          this->processor_mass);
+  }
+
+  // air_magic_number
+  const char* air_number_str = host->get_property("air_magic_number");
+  if (air_number_str != nullptr) {
+    try {
+      this->air_magic_number = std::stof(std::string(air_number_str));
+    } catch (std::invalid_argument& ia) {
+      throw std::invalid_argument(std::string("Invalid value for property air_magic_number of host ") + host->get_cname() +
+                                  ": " + air_number_str);
+    }
+  } else{
+  XBT_WARN("Missing value for property air_magic_number of host %s: Using default value %.2f watts", host->get_cname(),
+          this->air_magic_number);
+  }
+
+  // air_specific_heat
+  const char* fl_sp_heat_str = host->get_property("air_specific_heat");
+  if (fl_sp_heat_str != nullptr) {
+    try {
+      this->air_specific_heat = std::stof(std::string(fl_sp_heat_str));
+    } catch (std::invalid_argument& ia) {
+      throw std::invalid_argument(std::string("Invalid value for property air_specific_heat of host ") + host->get_cname() +
+                                  ": " + fl_sp_heat_str);
+    }
+  } else{
+    XBT_WARN("Missing value for property air_specific_heat of host %s: Using default value %.2f", host->get_cname(),
+            this->air_specific_heat);
+  }
+
+  //air_mass
+  const char* fl_mass_str = host->get_property("grams_air_mass");
+  if (fl_mass_str != nullptr) {
+    try {
+      this->air_mass = std::stof(std::string(fl_mass_str));
+    } catch (std::invalid_argument& ia) {
+      throw std::invalid_argument(std::string("Invalid value for property grams_air_mass of host ") + host->get_cname() +
+                                  ": " + fl_mass_str);
+    }
+  } else{
+  XBT_WARN("Missing value for property grams_air_mass of host %s: Using default value %.2f grams", host->get_cname(),
+          this->air_mass);
+  }
+
+}
+
+HostTemperature::~HostTemperature() = default;
+
+double HostTemperature::getProcessorTemperature()
+{
+  if (last_updated < surf_get_clock()) // We need to simcall this as it modifies the environment
+    simgrid::simix::simcall(std::bind(&HostTemperature::update, this));
+
+  return proc_temperature;
+}
+
+double HostTemperature::getAirTemperature()
+{
+  if (last_updated < surf_get_clock()) // We need to simcall this as it modifies the environment
+    simgrid::simix::simcall(std::bind(&HostTemperature::update, this));
+
+  return air_temperature;
+}
+
+double HostTemperature::getEnergyConsumed()
+{
+  if (last_updated < surf_get_clock()) // We need to simcall this as it modifies the environment
+    simgrid::simix::simcall(std::bind(&HostTemperature::update, this));
+
+  return sg_host_get_consumed_energy(host);
+}
+
+double HostTemperature::getOutsideTemperature()
+{
+  return outside_temperature;
+}
+
+void HostTemperature::setOutsideTemperature(double temperature)
+{
+  if (last_updated < surf_get_clock()) // We need to simcall this as it modifies the environment
+    simgrid::simix::simcall(std::bind(&HostTemperature::update, this));
+
+  this->outside_temperature = temperature;
+}
+
+} // namespace plugin
+} // namespace simgrid
+
+using simgrid::plugin::HostTemperature;
+
+/* **************************** events  callback *************************** */
+static void on_creation(simgrid::s4u::Host& host)
+{
+  if (dynamic_cast<simgrid::s4u::VirtualMachine*>(&host)) // Ignore virtual machines
+    return;
+
+  // TODO Trace: set to zero the temperature variable associated to host->getName()
+
+  host.extension_set(new HostTemperature(&host));
+}
+
+static void on_action_state_change(simgrid::surf::CpuAction* action,
+                                   simgrid::kernel::resource::Action::State /*previous*/)
+{
+  for (simgrid::surf::Cpu* const& cpu : action->cpus()) {
+    simgrid::s4u::Host* host = cpu->get_host();
+    if (host != nullptr) {
+
+      // If it's a VM, take the corresponding PM
+      simgrid::s4u::VirtualMachine* vm = dynamic_cast<simgrid::s4u::VirtualMachine*>(host);
+      if (vm) // If it's a VM, take the corresponding PM
+        host = vm->get_pm();
+
+      // Get the host_temperature extension for the relevant host
+      HostTemperature* host_temperature = host->extension<HostTemperature>();
+
+      if (host_temperature->last_updated < surf_get_clock())
+        host_temperature->update();
+    }
+  }
+}
+
+/* This callback is fired either when the host changes its state (on/off) ("onStateChange") or its speed
+ * (because the user changed the pstate, or because of external trace events) ("onSpeedChange") */
+static void on_host_change(simgrid::s4u::Host& host)
+{
+ if (dynamic_cast<simgrid::s4u::VirtualMachine*>(&host)) // Ignore virtual machines
+    return;
+
+  HostTemperature* host_temperature = host.extension<HostTemperature>();
+
+  host_temperature->update();
+}
+
+static void on_host_destruction(simgrid::s4u::Host& host)
+{
+  if (dynamic_cast<simgrid::s4u::VirtualMachine*>(&host)) // Ignore virtual machines
+    return;
+
+  if (!strcmp(host.get_cname(),"master_host") || !strcmp(host.get_cname(),"storage_server"))
+    return;
+
+  HostTemperature* host_temperature = host.extension<HostTemperature>();
+  host_temperature->update();
+  double tot_energy = host_temperature->getEnergyConsumed();
+  if (tot_energy > 1e6){
+    XBT_INFO("[Host %s] CPU temperature: %.2f °C, Air temperature: %.2f °C, Outside temperature: %.2f °C, Total energy consumed: %.0f kJ",
+            host.get_cname(), host_temperature->getProcessorTemperature(),
+            host_temperature->getAirTemperature(), host_temperature->getOutsideTemperature(), (tot_energy / 1000.0));
+  }
+  else{
+    XBT_INFO("[Host %s] CPU temperature: %.2f °C, Air temperature: %.2f °C, Outside temperature: %.2f °C, Total energy consumed %.0f J",
+            host.get_cname(), host_temperature->getProcessorTemperature(),
+            host_temperature->getAirTemperature(), host_temperature->getOutsideTemperature(), tot_energy);
+  }
+}
+
+static void on_simulation_end()
+{
+  /*TODO: Do nothing. Maybe do something in another version
+   */
+  return;
+}
+
+/* **************************** Public interface *************************** */
+
+/** \ingroup plugin_temperature
+ * \brief Enable host temperature plugin
+ * \details Enable temperature plugin to get the temperature of each cpu. Call this function before #MSG_init().
+ */
+void sg_host_temperature_plugin_init()
+{
+  if (HostTemperature::EXTENSION_ID.valid())
+    return;
+  sg_host_energy_plugin_init();
+  HostTemperature::EXTENSION_ID = simgrid::s4u::Host::extension_create<HostTemperature>();
+
+  simgrid::s4u::Host::on_creation.connect(&on_creation);
+  simgrid::s4u::Host::on_state_change.connect(&on_host_change);
+  simgrid::s4u::Host::on_destruction.connect(&on_host_destruction);
+  simgrid::surf::CpuAction::on_state_change.connect(&on_action_state_change);
+}
+
+
+/** @ingroup plugin_temperature
+ *  @brief Returns the current temperature by the host (in Celcius)
+ *
+ *  Please note that since the temperature is lazily updated, it may require a simcall to update it.
+ *  The result is that the actor requesting this value will be interrupted,
+ *  the value will be updated in kernel mode before returning the control to the requesting actor.
+ */
+double sg_host_get_processor_temperature(sg_host_t host)
+{
+  xbt_assert(HostTemperature::EXTENSION_ID.valid(),
+             "The Temperature plugin is not active. Please call sg_temperature_plugin_init() during initialization.");
+  return host->extension<HostTemperature>()->getProcessorTemperature();
+}
+
+/** @ingroup plugin_temperature
+ *  @brief Returns the total temperature consumed by the host so far (in Celcius)
+ *  Please note that since the temperature is lazily updated, it may require a simcall to update it.
+ *  The result is that the actor requesting this value will be interrupted,
+ *  the value will be updated in kernel mode before returning the control to the requesting actor.
+ */
+double sg_host_get_air_temperature(sg_host_t host)
+{
+  xbt_assert(HostTemperature::EXTENSION_ID.valid(),
+             "The Temperature plugin is not active. Please call sg_temperature_plugin_init() during initialization.");
+  return host->extension<HostTemperature>()->getAirTemperature();
+}
+
+/** @ingroup plugin_temperature
+ *  @brief Sets the outside world temperature to the temperature given in argument.
+ *  Please note that since the temperature is lazily updated, it may require a simcall to update it.
+ *  The result is that the actor requesting this value will be interrupted,
+ *  the value will be updated in kernel mode before returning the control to the requesting actor.
+ */
+void sg_host_set_outside_temperature(sg_host_t host, double temperature)
+{
+  xbt_assert(HostTemperature::EXTENSION_ID.valid(),
+             "The Temperature plugin is not active. Please call sg_temperature_plugin_init() during initialization.");
+
+  host->extension<HostTemperature>()->setOutsideTemperature(temperature);
+}
+
+/** @ingroup plugin_temperature
+ *  @brief updates the temperatures of the host
+ */
+void sg_host_update_temperatures(sg_host_t host)
+{
+  xbt_assert(HostTemperature::EXTENSION_ID.valid(),
+             "The Temperature plugin is not active. Please call sg_temperature_plugin_init() during initialization.");
+  host->extension<HostTemperature>()->update();
+}
diff --git a/tools/cmake/DefinePackages.cmake b/tools/cmake/DefinePackages.cmake
index 493b62f5e..9be1ad7d7 100644
--- a/tools/cmake/DefinePackages.cmake
+++ b/tools/cmake/DefinePackages.cmake
@@ -353,6 +353,7 @@ set(PLUGINS_SRC
   src/plugins/host_dvfs.cpp
   src/plugins/host_energy.cpp
   src/plugins/link_energy.cpp
+  src/plugins/host_temperature.cpp
   src/plugins/host_load.cpp
   src/plugins/file_system/s4u_FileSystem.cpp
   src/plugins/vm/VirtualMachineImpl.hpp
@@ -667,6 +668,7 @@ set(headers_to_install
   include/simgrid/chrono.hpp
   include/simgrid/plugins/dvfs.h
   include/simgrid/plugins/energy.h
+  include/simgrid/plugins/temperature.h
   include/simgrid/plugins/file_system.h
   include/simgrid/plugins/live_migration.h
   include/simgrid/plugins/load.h
